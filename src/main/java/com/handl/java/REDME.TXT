01.子类可以拥有父类私有属性，但不能直接使用，需要通过父类提供的封装方法调用
02.类变量会初始化值并设置默认初始化值，局部变量不会初始化，需要显示初始化
03.gc的四种引用类型：
        强引用:不会被垃圾回收机制回收
        软引用:只有内存不够的时候才会回收
        弱引用:垃圾回收机制只要执行就肯定回收
        虚引用:不知道什么时候就被回收
04.类的初始化顺序
        1、初始化父类的静态变量，静态代码块，初始化的顺序按照出现顺序。
        2、初始化子类的静态变量，静态代码块。
        3、初始化父类的成员变量。
        4、执行父类的构造函数。
        5、初始化子类的成员变量。
        6、构造代码块创建对象时执行。
        7、执行子类的构造函数。

05.final关键字 ：
    修饰属性：被final修饰的属性不可改变，对于基本类型则是不可改变值，
            对于引用类型，则不可改变引用的对象，但对象本身是可改变的。
    修饰参数列表：被final修饰的方法参数在方法中是不可以改变的，不可改变和修饰属性是一样的。
    修饰方法：被final修饰的方式是不能够被子类重写的
    修饰类：被final修饰的类，是不能被继承的。
    final和static一起使用则说明是一个常量。

06.面向对象三大特征：封装、多态、继承
    封装：通过合并特性和行为来创建新的数据类型，隐藏细节。
    多态：将接口和实现分离，消除类型之间的耦合
    继承：在不改变原有类的情况下，添加新的功能。

07.子类可以通过向下转型来调用扩展方法,但这不是安全的

08.内部类:使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，
        所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
    1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。
    2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
    3、创建内部类对象的时刻并不依赖于外围类对象的创建。
    4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
    5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。
    6、一个内部类被嵌套多少层不重要，它都可以透明的访问外围类的所有成员。

    1).成员内部类：成员内部类也是最普通的内部类，它是外围类的一个成员，
                所以他是可以无限制的访问外围类的所有 成员属性和方法，
                尽管是private的，但是外围类要访问内部类的成员属性和
                方法则需要通过内部类实例来访问。
            注意两点：
                1.成员内部类中不能存在任何static的变量和方法
                2.成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类
                    外部类.内部类 innerClass = new 外部类().new 内部类()

    2).局部内部类:嵌套在方法和作用于内的,它只能在该方法和属性中被使用，
                出了该方法和属性就会失效。

    3).匿名内部类:
             1、 匿名内部类是没有访问修饰符的。
             2、 new 匿名内部类，这个类(接口或者抽象类)首先是要存在的。
             3、 当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。
             4、 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。

    4).静态内部类:使用static修饰的内部类我们称之为静态内部类，也称之为嵌套内部类
            非静态内部类之间存在一个最大的区别：
                非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，
                但是静态内部类却没有。没有这个引用就意味着：
                  1、 它的创建是不需要依赖于外围类的。
                  2、 它不能使用任何外围类的非static成员变量和方法。
                  3、 它本身的属性和方法可以是静态的或者是非静态的

    5).接口中的内部类(静态内部类)：在接口中定义内部类可以实现接口本身，并重写其接口

09.容器：
    两种容器类型，区别在于每个槽保存的元素个数
        Collection：在每个槽只保存一个元素
                List:以特定的顺序保存一组元素
                    ArrayList:随机访问速度较快，但随机插入和移除元素较慢
                    LinkedList:随机插入和移除元素较快，随机访问较慢
                Set:元素不能重复
                    HashSet:获取元素最快，没有固定顺序
                    TreeSet:按照比较结果按升序排序
                    LinkedHashSet:按照被添加的顺序存储对象
                Queue:队列，"先进先出"的容器只允许在容器的一端插入对象，并从另一端取出对象,LinkedList提供了方法以支持队列。
                    PriorityQueue：优先级队列，这个对象会在队列中被排序。
                Stack:栈，"后进先出"的容器,LinkedList具有直接实现栈的所有功能。
        Map:在每个槽内保存了两个对象，键值对
                    HashMap:
                    TreeMap:
                    LinkedHashMap:

10.多线程：
    syncchronized作用于非静态资源(非static的方法或者变量)，仅仅是锁住了当前对象，防止多线程同时访问当前对象的同步资源，
    对于两个不同共享资源(一个类中两个或以上的方法或属性)都锁住了同一个对象，那么也不能在多线程环境下同时执行，因为都是同一个锁(当前对象锁)

    线程的四种状态：新建、就绪、阻塞、死亡
        新建：创建线程，并分配资源和初始化操作，这个过程很短暂，当这些完成时，
            调度器将把这个线程置为运行状态或者是阻塞状态。

        就绪：只要调度器把CPU的执行时间片段分给线程，那么就可以立即执行。

        阻塞：线程本身是在运行中，或者说线程能够运行，但是由于某些限制，比如sleep(),致使线程
            处于阻塞状态。调度器会忽略阻塞的线程，直到线程重新进入就绪状态，得到调度器分配的
            时间分片才能执行。

        死亡：处理死亡或者终止状态的线程不再是可调度的，并且不会得到CPU的时间片段，通常来讲就是
            run()方法返回

    sleep()：不释放锁
    yeild():不释放锁
    wait():释放锁